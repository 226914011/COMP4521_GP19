"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _TileSet_tiles;
Object.defineProperty(exports, "__esModule", { value: true });
const Tile_1 = require("./Tile");
/**
 * This class simulates the Tile set for a Mahjong Game.
 */
class TileSet {
    /**
     * Construct a TileSet.
     */
    constructor() {
        /**
         * Mahjong Tiles.
         */
        _TileSet_tiles.set(this, void 0);
        __classPrivateFieldSet(this, _TileSet_tiles, [], "f");
        const suits = Object.keys(Tile_1.default.ALL_SUIT_TYPES);
        for (const suit of suits) {
            for (let tileValue = 1; tileValue <= Tile_1.default.ALL_SUIT_TYPES[suit]['maxValue']; tileValue++) {
                for (let i = 0; i < 4; i++) {
                    __classPrivateFieldGet(this, _TileSet_tiles, "f").push(new Tile_1.default({ suit, value: tileValue }));
                }
            }
        }
        this.shuffleTiles();
    }
    /**
     * Access all Tiles of the TileSet.
     * @returns all Tiles of the TileSet.
     */
    getAllTiles() {
        return __classPrivateFieldGet(this, _TileSet_tiles, "f").slice();
    }
    /**
     * Draw one Tile from the TileSet.
     * @returns a Tile from the TileSet.
     */
    getOneTile() {
        if (this.hasNoMoreTiles()) {
            throw new Error('There are no more Tiles.');
        }
        else {
            const result = __classPrivateFieldGet(this, _TileSet_tiles, "f").shift();
            if (result === undefined) {
                throw new Error('There are no more Tiles.');
            }
            else {
                return result;
            }
        }
    }
    /**
     * Determine if all Tiles have been drawn.
     * @returns true if there are no more Tiles.
     */
    hasNoMoreTiles() {
        return __classPrivateFieldGet(this, _TileSet_tiles, "f").length === 0;
    }
    /**
     * Shuffle the tiles.
     * @param numberOfShuffles number of shuffles.
     */
    shuffleTiles(numberOfShuffles) {
        for (let shuffleRound = 0; shuffleRound < (numberOfShuffles || 10); shuffleRound++) {
            for (let i = __classPrivateFieldGet(this, _TileSet_tiles, "f").length - 1; i > 0; i--) {
                const randomIndex = Math.floor(Math.random() * (i + 1));
                const temp = __classPrivateFieldGet(this, _TileSet_tiles, "f")[i];
                __classPrivateFieldGet(this, _TileSet_tiles, "f")[i] = __classPrivateFieldGet(this, _TileSet_tiles, "f")[randomIndex];
                __classPrivateFieldGet(this, _TileSet_tiles, "f")[randomIndex] = temp;
            }
        }
    }
}
exports.default = TileSet;
_TileSet_tiles = new WeakMap();
