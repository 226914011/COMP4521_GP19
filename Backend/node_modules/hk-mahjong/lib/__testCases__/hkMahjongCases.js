"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("../index");
const riichiCases_1 = require("./riichiCases");
const tileToUnicodeMap = {
    '1m': '🀇',
    '2m': '🀈',
    '3m': '🀉',
    '4m': '🀊',
    '5m': '🀋',
    '6m': '🀌',
    '7m': '🀍',
    '8m': '🀎',
    '9m': '🀏',
    '1p': '🀙',
    '2p': '🀚',
    '3p': '🀛',
    '4p': '🀜',
    '5p': '🀝',
    '6p': '🀞',
    '7p': '🀟',
    '8p': '🀠',
    '9p': '🀡',
    '1s': '🀐',
    '2s': '🀑',
    '3s': '🀒',
    '4s': '🀓',
    '5s': '🀔',
    '6s': '🀕',
    '7s': '🀖',
    '8s': '🀗',
    '9s': '🀘',
    '1z': '🀀',
    '2z': '🀁',
    '3z': '🀂',
    '4z': '🀃',
    '5z': '🀆',
    '6z': '🀅',
    '7z': '🀄',
};
const convertStringToHand = (hand) => {
    const tileString = hand.slice(0, 26).match(/.{1,2}/g);
    const lastTileChar = hand[26] !== '+' ? hand.slice(26, 28) : hand.slice(27, 29);
    if (tileString !== null) {
        const tiles = [];
        for (const tileChar of tileString) {
            const tileUnicode = tileToUnicodeMap[tileChar];
            tiles.push(new index_1.Tile(tileUnicode));
        }
        tiles.push(new index_1.Tile(tileToUnicodeMap[lastTileChar]));
        return new index_1.Hand({ tiles });
    }
    throw new Error('Tile String is not a valid Hand.');
};
const isSevenPairs = (handInput) => {
    const map = {};
    const tilesString = handInput.toString();
    for (const tile of tilesString) {
        if (map[tile] === undefined) {
            map[tile] = 1;
        }
        else {
            map[tile]++;
        }
    }
    let numberOfPairs = 0;
    for (const tile in map) {
        if (map[tile] === 2) {
            numberOfPairs++;
        }
    }
    return numberOfPairs === 7;
};
const hkMahjongCases = riichiCases_1.default
    .map((dataString) => convertStringToHand(dataString))
    .filter((hand) => !isSevenPairs(hand));
exports.default = hkMahjongCases;
