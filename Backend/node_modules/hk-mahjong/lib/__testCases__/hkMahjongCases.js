"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("../index");
const riichiCases_1 = require("./riichiCases");
const tileToUnicodeMap = {
    '1m': 'ðŸ€‡',
    '2m': 'ðŸ€ˆ',
    '3m': 'ðŸ€‰',
    '4m': 'ðŸ€Š',
    '5m': 'ðŸ€‹',
    '6m': 'ðŸ€Œ',
    '7m': 'ðŸ€',
    '8m': 'ðŸ€Ž',
    '9m': 'ðŸ€',
    '1p': 'ðŸ€™',
    '2p': 'ðŸ€š',
    '3p': 'ðŸ€›',
    '4p': 'ðŸ€œ',
    '5p': 'ðŸ€',
    '6p': 'ðŸ€ž',
    '7p': 'ðŸ€Ÿ',
    '8p': 'ðŸ€ ',
    '9p': 'ðŸ€¡',
    '1s': 'ðŸ€',
    '2s': 'ðŸ€‘',
    '3s': 'ðŸ€’',
    '4s': 'ðŸ€“',
    '5s': 'ðŸ€”',
    '6s': 'ðŸ€•',
    '7s': 'ðŸ€–',
    '8s': 'ðŸ€—',
    '9s': 'ðŸ€˜',
    '1z': 'ðŸ€€',
    '2z': 'ðŸ€',
    '3z': 'ðŸ€‚',
    '4z': 'ðŸ€ƒ',
    '5z': 'ðŸ€†',
    '6z': 'ðŸ€…',
    '7z': 'ðŸ€„',
};
const convertStringToHand = (hand) => {
    const tileString = hand.slice(0, 26).match(/.{1,2}/g);
    const lastTileChar = hand[26] !== '+' ? hand.slice(26, 28) : hand.slice(27, 29);
    if (tileString !== null) {
        const tiles = [];
        for (const tileChar of tileString) {
            const tileUnicode = tileToUnicodeMap[tileChar];
            tiles.push(new index_1.Tile(tileUnicode));
        }
        tiles.push(new index_1.Tile(tileToUnicodeMap[lastTileChar]));
        return new index_1.Hand({ tiles });
    }
    throw new Error('Tile String is not a valid Hand.');
};
const isSevenPairs = (handInput) => {
    const map = {};
    const tilesString = handInput.toString();
    for (const tile of tilesString) {
        if (map[tile] === undefined) {
            map[tile] = 1;
        }
        else {
            map[tile]++;
        }
    }
    let numberOfPairs = 0;
    for (const tile in map) {
        if (map[tile] === 2) {
            numberOfPairs++;
        }
    }
    return numberOfPairs === 7;
};
const hkMahjongCases = riichiCases_1.default
    .map((dataString) => convertStringToHand(dataString))
    .filter((hand) => !isSevenPairs(hand));
exports.default = hkMahjongCases;
