"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _WinningHand_melds;
Object.defineProperty(exports, "__esModule", { value: true });
// import countTilesOccurrences from "./countTilesOccurrences";
// import ExplorerOfWinningPermutations from "./depthFirstSearch/ExplorerOfWinningPermutations";
const FaanCalculator_1 = require("../calculateFaan/FaanCalculator");
const MeldType_1 = require("../meld/MeldType");
const getTilesOccurrencesMap_1 = require("../tile/getTilesOccurrencesMap");
const __1 = require("..");
/**
 *
 */
class WinningHand {
    /**
     *
     * @param meldsInput
     */
    constructor(meldsInput) {
        /**
         *
         */
        _WinningHand_melds.set(this, void 0);
        const isSpecialWinningHand = meldsInput.length === WinningHand.NUMBER_OF_MELDS_NEEDED_FOR_THIRTEEN_ORPHANS &&
            meldsInput[0].getMeldType() === MeldType_1.MeldType.THIRTEEN_ORPHANS;
        if (isSpecialWinningHand) {
            __classPrivateFieldSet(this, _WinningHand_melds, meldsInput, "f");
        }
        else {
            const hasInsufficientMelds = meldsInput.length < WinningHand.NUMBER_OF_MELDS_NEEDED_FOR_STANDARD_FORM;
            const hasExcessMelds = meldsInput.length > WinningHand.NUMBER_OF_MELDS_NEEDED_FOR_STANDARD_FORM;
            if (hasInsufficientMelds)
                throw new Error('A winning hand should have 5 melds.');
            if (hasExcessMelds)
                throw new Error('A winning hand should have 5 melds.');
            __classPrivateFieldSet(this, _WinningHand_melds, meldsInput, "f");
        }
        if (!this.occurrenceOfEachTileIsWithinLimit()) {
            throw new Error('Invalid input.  Each tile should only have 4 occurrences at maximum.');
        }
    }
    /**
     *
     * @returns
     */
    getMelds() {
        return __classPrivateFieldGet(this, _WinningHand_melds, "f").slice();
    }
    /**
     *
     * @returns
     */
    toString() {
        const isThirteenOrphans = __classPrivateFieldGet(this, _WinningHand_melds, "f").length === WinningHand.NUMBER_OF_MELDS_NEEDED_FOR_THIRTEEN_ORPHANS;
        if (isThirteenOrphans) {
            return __classPrivateFieldGet(this, _WinningHand_melds, "f")[0].toString();
        }
        else {
            let eyes = '';
            let result = '';
            for (const meld of __classPrivateFieldGet(this, _WinningHand_melds, "f")) {
                if (meld.getMeldType() === MeldType_1.MeldType.EYES) {
                    eyes = meld.toString();
                    continue;
                }
                result += meld.toString() + ' ';
            }
            if (eyes.length === 0) {
                throw new Error('Eyes are not found in the Winning Hand');
            }
            else {
                return result + eyes;
            }
        }
    }
    /**
     *
     * @returns
     */
    convertToTiles() {
        const tiles = [];
        for (const meld of __classPrivateFieldGet(this, _WinningHand_melds, "f")) {
            meld.getTiles().forEach((tile) => tiles.push(tile));
        }
        return tiles;
    }
    /**
     *
     * @returns
     */
    covertToHand() {
        return new __1.Hand({ melds: __classPrivateFieldGet(this, _WinningHand_melds, "f").slice() });
    }
    /**
     *
     * @returns
     */
    calculateFaan() {
        const { value: valueOfFaan } = FaanCalculator_1.default.calculate(this);
        return valueOfFaan;
    }
    /**
     *
     * @param inputTile
     * @returns
     */
    contain(inputTile) {
        const tiles = this.convertToTiles();
        for (const tile of tiles) {
            if (tile.isIdentical(inputTile)) {
                return true;
            }
        }
        return false;
    }
    /**
     *
     * @returns
     */
    occurrenceOfEachTileIsWithinLimit() {
        const tiles = this.convertToTiles();
        const map = (0, getTilesOccurrencesMap_1.default)(tiles);
        for (const suit in map) {
            // Requirement of TSLint: for (... in ...) statements must be filtered with an if statement.
            if (map.hasOwnProperty(suit)) {
                for (const value in map[suit]) {
                    // Requirement of TSLint: for (... in ...) statements must be filtered with an if statement.
                    if (map[suit].hasOwnProperty(value)) {
                        if (map[suit][value] > 4) {
                            return false;
                        }
                    }
                }
            }
        }
        return true;
    }
}
_WinningHand_melds = new WeakMap();
/**
 *
 */
WinningHand.NUMBER_OF_MELDS_NEEDED_FOR_STANDARD_FORM = 5;
/**
 *
 */
WinningHand.NUMBER_OF_MELDS_NEEDED_FOR_THIRTEEN_ORPHANS = 1;
exports.default = WinningHand;
