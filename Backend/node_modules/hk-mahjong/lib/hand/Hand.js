"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Hand_unorganizedTiles, _Hand_meldsFormed, _Hand_allTiles;
Object.defineProperty(exports, "__esModule", { value: true });
const countTilesOccurrences_1 = require("../tile/countTilesOccurrences");
const ExplorerOfWinningPermutations_1 = require("../breadthFirstSearch/ExplorerOfWinningPermutations");
const isThirteenOrphans_1 = require("./handType/isThirteenOrphans");
const MeldType_1 = require("../meld/MeldType");
const FaanCalculator_1 = require("../calculateFaan/FaanCalculator");
class Hand {
    /**
     * Construct a Hand.
     * @param inputConfig configuration of constructing a Hand.
     */
    constructor(inputConfig) {
        /**
         * Unorganized tiles.
         */
        _Hand_unorganizedTiles.set(this, void 0);
        /**
         * Melds formed.
         */
        _Hand_meldsFormed.set(this, void 0);
        /**
         * All tiles from the array of unorganized Tiles and the array of Melds formed.
         */
        _Hand_allTiles.set(this, void 0);
        const hasInsufficientParams = inputConfig.tiles === undefined && inputConfig.melds === undefined;
        if (hasInsufficientParams) {
            throw new Error('Insufficient parameters to instantiate a Hand.');
        }
        if (inputConfig.tiles) {
            __classPrivateFieldSet(this, _Hand_unorganizedTiles, inputConfig.tiles.slice(), "f");
        }
        else {
            __classPrivateFieldSet(this, _Hand_unorganizedTiles, [], "f");
        }
        if (inputConfig.melds) {
            if (inputConfig.tiles && inputConfig.tiles.length > 0) {
                inputConfig.melds.forEach((meld) => {
                    if (meld.getMeldType() === MeldType_1.MeldType.THIRTEEN_ORPHANS) {
                        throw new Error('There should be no tiles remain unorganized if the Meld is in the type of THIRTEEN_ORPHANS.');
                    }
                });
            }
            __classPrivateFieldSet(this, _Hand_meldsFormed, inputConfig.melds.slice(), "f");
        }
        else {
            __classPrivateFieldSet(this, _Hand_meldsFormed, [], "f");
        }
        __classPrivateFieldSet(this, _Hand_allTiles, [], "f");
        for (const meld of __classPrivateFieldGet(this, _Hand_meldsFormed, "f")) {
            __classPrivateFieldSet(this, _Hand_allTiles, __classPrivateFieldGet(this, _Hand_allTiles, "f").concat(meld.getTiles()), "f");
        }
        __classPrivateFieldSet(this, _Hand_allTiles, __classPrivateFieldGet(this, _Hand_allTiles, "f").concat(__classPrivateFieldGet(this, _Hand_unorganizedTiles, "f")), "f");
        if (__classPrivateFieldGet(this, _Hand_allTiles, "f").length < Hand.MIN_NUMBER_OF_TILES) {
            throw new Error('Short Hand.');
        }
        else if (__classPrivateFieldGet(this, _Hand_allTiles, "f").length > Hand.MAX_NUMBER_OF_TILES) {
            throw new Error('Long Hand.');
        }
    }
    /**
     * Access the unorganized Tiles.
     * @returns {Tile []} the unorganized Tiles.
     */
    getUnorganizedTiles() {
        return __classPrivateFieldGet(this, _Hand_unorganizedTiles, "f").slice();
    }
    /**
     * Access the Melds formed.
     * @returns {Meld []} the Melds formed.
     */
    getMeldsFormed() {
        return __classPrivateFieldGet(this, _Hand_meldsFormed, "f").slice();
    }
    /**
     * Access all Tiles.
     * @returns {Tile []} an array including all Tiles (either unorganized or from the formed Melds).
     */
    getAllTiles() {
        return __classPrivateFieldGet(this, _Hand_allTiles, "f").slice();
    }
    /**
     * Access the string that could represent the Tiles of the Hand.
     * @returns {string} a string that represent the Tiles of the Hand.
     */
    toString() {
        let result = '';
        for (const tile of __classPrivateFieldGet(this, _Hand_allTiles, "f")) {
            result += tile.toString();
        }
        return result;
    }
    /**
     * Determine if two Hands are the same.
     * @param handToBeCompared Hand to be compared.
     * @returns {boolean} true if the two Hands are the same..
     */
    isIdentical(handToBeCompared) {
        if (__classPrivateFieldGet(this, _Hand_unorganizedTiles, "f").length !== handToBeCompared.getUnorganizedTiles().length) {
            return false;
        }
        for (const tile of __classPrivateFieldGet(this, _Hand_unorganizedTiles, "f")) {
            if ((0, countTilesOccurrences_1.default)(__classPrivateFieldGet(this, _Hand_unorganizedTiles, "f"), tile) !==
                (0, countTilesOccurrences_1.default)(handToBeCompared.getUnorganizedTiles(), tile)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Determine if the Hand is a ThirteenOrphans.
     * @returns {boolean} true if the Hand is a ThirteenOrphans.
     */
    isThirteenOrphans() {
        try {
            return (0, isThirteenOrphans_1.isThirteenOrphansAsTilesArray)(__classPrivateFieldGet(this, _Hand_unorganizedTiles, "f"));
        }
        catch (err) {
            return false;
        }
    }
    /**
     * Determine if the Hand is a WinningHand.
     * @returns  {boolean} true if the Hand is a WinningHand.
     */
    isWinningHand() {
        try {
            if (this.isThirteenOrphans())
                return true;
            const explorer = new ExplorerOfWinningPermutations_1.default(this);
            const winningPermutations = explorer
                .getWinningPermutations()
                .filter((winningPermutation) => winningPermutation.calculateFaan() === '∞' ||
                (winningPermutation.calculateFaan() !== '∞' &&
                    winningPermutation.calculateFaan() >= FaanCalculator_1.default.getThresholdFaanValue()));
            return winningPermutations.length > 0;
        }
        catch (err) {
            return false;
        }
    }
    /**
     * Determine if the Hand is able to be grouped into 5 Melds.
     * @returns  {boolean} true if the Hand is a WinningHand.
     */
    isAbleToGroupAsMelds() {
        try {
            if (this.isThirteenOrphans())
                return true;
            const explorer = new ExplorerOfWinningPermutations_1.default(this);
            const results = explorer.getWinningPermutations();
            return results.length > 0;
        }
        catch (err) {
            return false;
        }
    }
    /**
     * Find all possible winning permutations of the Hand.
     * @returns {WinningHand []} all possible winning permutations of the Hand.
     */
    findAllWinningPermutations() {
        try {
            const explorer = new ExplorerOfWinningPermutations_1.default(this);
            const result = explorer.getWinningPermutations();
            return result;
        }
        catch (err) {
            return [];
        }
    }
}
_Hand_unorganizedTiles = new WeakMap(), _Hand_meldsFormed = new WeakMap(), _Hand_allTiles = new WeakMap();
/**
 * Minimum number of Tiles required in a Mahjong Hand.
 */
Hand.MIN_NUMBER_OF_TILES = 13;
/**
 * Maximum number of Tiles accepted in a Mahjong Hand.
 */
Hand.MAX_NUMBER_OF_TILES = 18;
exports.default = Hand;
