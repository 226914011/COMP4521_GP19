"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ExplorerOfWinningPermutations_permutationsExplored, _ExplorerOfWinningPermutations_handInput;
Object.defineProperty(exports, "__esModule", { value: true });
const MeldType_1 = require("../meld/MeldType");
const NodeForSearching_1 = require("./NodeForSearching");
const QueueFrontier_1 = require("./QueueFrontier");
const WinningHand_1 = require("../hand/WinningHand");
const updateTileArray_1 = require("../tile/updateTileArray");
const chows_1 = require("../meld/chows");
const kongs_1 = require("../meld/kongs");
const pongs_1 = require("../meld/pongs");
const eyes_1 = require("../meld/eyes");
const isThirteenOrphans_1 = require("../hand/handType/isThirteenOrphans");
/**
 * This class explores all possible winning permutation of a Hand.
 */
class ExplorerOfWinningPermutations {
    /**
     * Construct an instance of the class.
     * @param input the Mahjong Hand of which the winning permutation has to be explored.
     */
    constructor(input) {
        /**
         * The WinningHand that has been already explored.
         */
        _ExplorerOfWinningPermutations_permutationsExplored.set(this, void 0);
        /**
         * The Mahjong Hand of which the winning permutation has to be explored.
         */
        _ExplorerOfWinningPermutations_handInput.set(this, void 0);
        __classPrivateFieldSet(this, _ExplorerOfWinningPermutations_handInput, input, "f");
        __classPrivateFieldSet(this, _ExplorerOfWinningPermutations_permutationsExplored, [], "f");
    }
    /**
     * Access the Winning permutations of the Mahjong Hand.
     * @returns {WinningHand []} the Winning permutations of the Mahjong Hand.
     */
    getWinningPermutations() {
        this.performBreadthFirstSearch();
        return __classPrivateFieldGet(this, _ExplorerOfWinningPermutations_permutationsExplored, "f");
    }
    /**
     * Perform the Breadth First search.
     */
    performBreadthFirstSearch() {
        const initNode = new NodeForSearching_1.default(__classPrivateFieldGet(this, _ExplorerOfWinningPermutations_handInput, "f").getUnorganizedTiles(), null, null, __classPrivateFieldGet(this, _ExplorerOfWinningPermutations_handInput, "f").getMeldsFormed());
        const frontier = new QueueFrontier_1.default();
        frontier.add(initNode);
        while (true) {
            if (frontier.empty()) {
                break;
            }
            // Retrieve the first node from the frontier for further processing in the latter part.  Meanwhile, the retrieval action would remove the first node from the frontier.
            const node = frontier.remove();
            const unorganizedTiles = node.getUnorganizedTiles();
            // Identify if the Hand is a ThirteenOrphans.
            if ((0, isThirteenOrphans_1.isThirteenOrphansAsTilesArray)(unorganizedTiles)) {
                const meld = (0, isThirteenOrphans_1.convertThirteenOrphansToMeld)(unorganizedTiles);
                __classPrivateFieldGet(this, _ExplorerOfWinningPermutations_permutationsExplored, "f").push(new WinningHand_1.default([meld]));
                break;
            }
            const meldsFormed = node.getMeldsFormed();
            if (meldsFormed.length === 1 && meldsFormed[0].getMeldType() === MeldType_1.MeldType.THIRTEEN_ORPHANS) {
                __classPrivateFieldGet(this, _ExplorerOfWinningPermutations_permutationsExplored, "f").push(new WinningHand_1.default(meldsFormed));
                break;
            }
            // Evaluate if the Hand is able to form a standard WinningHand
            const isAbleToFormStandardWinningHand = unorganizedTiles.length === 0 &&
                meldsFormed.length === WinningHand_1.default.NUMBER_OF_MELDS_NEEDED_FOR_STANDARD_FORM &&
                (0, eyes_1.hasOnePairOfEyes)(meldsFormed);
            if (isAbleToFormStandardWinningHand) {
                __classPrivateFieldGet(this, _ExplorerOfWinningPermutations_permutationsExplored, "f").push(new WinningHand_1.default(meldsFormed));
            }
            if (meldsFormed.length === WinningHand_1.default.NUMBER_OF_MELDS_NEEDED_FOR_STANDARD_FORM - 1) {
                const eyesFormed = (0, eyes_1.default)(unorganizedTiles);
                const isAbleToFormEyes = eyesFormed !== null;
                if (isAbleToFormEyes) {
                    const meldType = MeldType_1.MeldType.EYES;
                    const unorganizedTilesAfterFormingEyes = (0, updateTileArray_1.default)(unorganizedTiles, eyesFormed);
                    const melds = node.getMeldsFormed();
                    melds.push(eyesFormed);
                    const childNode = new NodeForSearching_1.default(unorganizedTilesAfterFormingEyes, node, meldType, melds);
                    if (!frontier.contain(childNode)) {
                        frontier.add(childNode);
                    }
                }
            }
            const kongsFormed = (0, kongs_1.default)(unorganizedTiles);
            for (const kongFormed of kongsFormed) {
                const meldType = MeldType_1.MeldType.KONG;
                const unorganizedTilesAfterFormingKong = (0, updateTileArray_1.default)(unorganizedTiles, kongFormed);
                const melds = node.getMeldsFormed();
                melds.push(kongFormed);
                const childNode = new NodeForSearching_1.default(unorganizedTilesAfterFormingKong, node, meldType, melds);
                if (!frontier.contain(childNode)) {
                    frontier.add(childNode);
                }
            }
            const pongsFormed = (0, pongs_1.default)(unorganizedTiles);
            for (const pongFormed of pongsFormed) {
                const meldType = MeldType_1.MeldType.PONG;
                const unorganizedTilesAfterFormingPong = (0, updateTileArray_1.default)(unorganizedTiles, pongFormed);
                const melds = node.getMeldsFormed();
                melds.push(pongFormed);
                const childNode = new NodeForSearching_1.default(unorganizedTilesAfterFormingPong, node, meldType, melds);
                if (!frontier.contain(childNode)) {
                    frontier.add(childNode);
                }
            }
            const chowsFormed = (0, chows_1.default)(unorganizedTiles);
            for (const chowFormed of chowsFormed) {
                const meldType = MeldType_1.MeldType.CHOW;
                const unorganizedTilesAfterFormingChow = (0, updateTileArray_1.default)(unorganizedTiles, chowFormed);
                const melds = node.getMeldsFormed();
                melds.push(chowFormed);
                const childNode = new NodeForSearching_1.default(unorganizedTilesAfterFormingChow, node, meldType, melds);
                if (!frontier.contain(childNode)) {
                    frontier.add(childNode);
                }
            }
        }
    }
}
_ExplorerOfWinningPermutations_permutationsExplored = new WeakMap(), _ExplorerOfWinningPermutations_handInput = new WeakMap();
exports.default = ExplorerOfWinningPermutations;
