"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _NodeForSearching_unorganizedTiles, _NodeForSearching_parent, _NodeForSearching_lastAction, _NodeForSearching_meldsFormed;
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This class is the Node used for performing the Breadth First Search.
 */
class NodeForSearching {
    /**
     * Construct the node.
     * @param unorganizedTiles The array of unorganized Tiles.
     * @param parent The parent node.
     * @param lastAction The last action that was taken to form meld and produces this node from its parent node.
     * @param meldsFormed The array of Melds that have been formed.
     */
    constructor(unorganizedTiles, parent, lastAction, meldsFormed) {
        /**
         * The array of unorganized Tiles.
         */
        _NodeForSearching_unorganizedTiles.set(this, void 0);
        /**
         * The parent node.
         */
        _NodeForSearching_parent.set(this, void 0);
        /**
         * The last action that was taken to form meld and produces this node from its parent node.
         */
        _NodeForSearching_lastAction.set(this, void 0);
        /**
         * The array of Melds that have been formed.
         */
        _NodeForSearching_meldsFormed.set(this, void 0);
        __classPrivateFieldSet(this, _NodeForSearching_unorganizedTiles, unorganizedTiles, "f");
        __classPrivateFieldSet(this, _NodeForSearching_parent, parent, "f");
        __classPrivateFieldSet(this, _NodeForSearching_lastAction, lastAction, "f");
        if (meldsFormed !== null) {
            __classPrivateFieldSet(this, _NodeForSearching_meldsFormed, meldsFormed, "f");
        }
        else {
            __classPrivateFieldSet(this, _NodeForSearching_meldsFormed, [], "f");
        }
    }
    /**
     * Compare if the Melds formed of two nodes are the same.
     * @param inputNode the node to be compared.
     * @returns {boolean} true if the Melds formed of the two nodes are the same.
     */
    isIdenticalMeldsFormed(inputNode) {
        const meldsOfThisNode = this.mapOccurrencesOfTilesInMeld(__classPrivateFieldGet(this, _NodeForSearching_meldsFormed, "f"));
        const meldsOfComparedNode = this.mapOccurrencesOfTilesInMeld(inputNode.getMeldsFormed());
        for (const meld in meldsOfThisNode) {
            // Requirement of TSLint: for (... in ...) statements must be filtered with an if statement.
            if (meldsOfThisNode.hasOwnProperty(meld)) {
                const meldOccurrencesIsDifferent = meldsOfComparedNode[meld] !== meldsOfThisNode[meld];
                if (meldOccurrencesIsDifferent) {
                    return false;
                }
            }
            else {
                return false;
            }
        }
        return true;
    }
    /**
     * Access the unorganized Tiles.
     * @returns {Tile []} unorganized Tiles.
     */
    getUnorganizedTiles() {
        return __classPrivateFieldGet(this, _NodeForSearching_unorganizedTiles, "f").slice();
    }
    /**
     * Access the parent node.
     * @returns {NodeForSearching | null} the parent node.
     */
    getParent() {
        return __classPrivateFieldGet(this, _NodeForSearching_parent, "f");
    }
    /**
     * Access the last action.
     * @returns {MeldType | null} last action that was taken to form meld and produces this node from its parent node. Null if the node has no parent node.
     */
    getLastAction() {
        return __classPrivateFieldGet(this, _NodeForSearching_lastAction, "f");
    }
    /**
     * Access the array of formed Melds.
     * @returns {Meld []} the array of Melds that have been formed.
     */
    getMeldsFormed() {
        return __classPrivateFieldGet(this, _NodeForSearching_meldsFormed, "f").slice();
    }
    /**
     * Count the occurrences of Tiles in a Meld.
     * @param inputMeld
     * @returns {MeldOccurrencesMap} a dictionary that maps the occurrences of Tiles in the Meld.
     */
    mapOccurrencesOfTilesInMeld(inputMeld) {
        const map = {};
        for (const meld of inputMeld) {
            const meldString = meld.toString();
            if (map[meldString]) {
                map[meldString]++;
            }
            else {
                map[meldString] = 1;
            }
        }
        return map;
    }
}
_NodeForSearching_unorganizedTiles = new WeakMap(), _NodeForSearching_parent = new WeakMap(), _NodeForSearching_lastAction = new WeakMap(), _NodeForSearching_meldsFormed = new WeakMap();
exports.default = NodeForSearching;
