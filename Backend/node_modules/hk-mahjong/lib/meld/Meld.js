"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Meld_tiles, _Meld_suitType, _Meld_meldType;
Object.defineProperty(exports, "__esModule", { value: true });
const MeldType_1 = require("./MeldType");
const isThirteenOrphans_1 = require("../hand/handType/isThirteenOrphans");
/**
 * This class represents Meld, which is a group of tiles that serves as a basic unit of forming a WinningHand.
 */
class Meld {
    /**
     * Construct the Meld.
     * @param inputTiles the input array of Tiles.
     */
    constructor(inputTiles) {
        /**
         * The array of Tiles that form the Meld.
         */
        _Meld_tiles.set(this, void 0);
        /**
         * Suit type of the Meld.
         */
        _Meld_suitType.set(this, void 0);
        /**
         * Meld type of the Meld.
         */
        _Meld_meldType.set(this, void 0);
        if ((0, isThirteenOrphans_1.isThirteenOrphansAsTilesArray)(inputTiles)) {
            __classPrivateFieldSet(this, _Meld_meldType, MeldType_1.MeldType.THIRTEEN_ORPHANS, "f");
            __classPrivateFieldSet(this, _Meld_tiles, (0, isThirteenOrphans_1.sortTilesInThirteenOrphans)(inputTiles), "f");
            __classPrivateFieldSet(this, _Meld_suitType, 'ThirteenOrphans', "f");
            return;
        }
        const allTilesAreInSameSuit = this.allTilesAreInSameSuit(inputTiles);
        if (!allTilesAreInSameSuit) {
            throw new Error('Invalid input of Meld. ll tiles in a meld must have the same suit.');
        }
        if (this.isValidEyes(inputTiles)) {
            __classPrivateFieldSet(this, _Meld_meldType, MeldType_1.MeldType.EYES, "f");
        }
        else if (this.isValidChow(inputTiles)) {
            __classPrivateFieldSet(this, _Meld_meldType, MeldType_1.MeldType.CHOW, "f");
        }
        else if (this.isValidPong(inputTiles)) {
            __classPrivateFieldSet(this, _Meld_meldType, MeldType_1.MeldType.PONG, "f");
        }
        else if (this.isValidKong(inputTiles)) {
            __classPrivateFieldSet(this, _Meld_meldType, MeldType_1.MeldType.KONG, "f");
        }
        else {
            throw new Error('Invalid input of Meld.');
        }
        if (__classPrivateFieldGet(this, _Meld_meldType, "f") === MeldType_1.MeldType.CHOW) {
            __classPrivateFieldSet(this, _Meld_tiles, inputTiles.sort((tile1, tile2) => tile1.getValue() - tile2.getValue()), "f");
        }
        else {
            __classPrivateFieldSet(this, _Meld_tiles, inputTiles, "f");
        }
        __classPrivateFieldSet(this, _Meld_suitType, inputTiles[0].getSuit(), "f");
    }
    getTiles() {
        return __classPrivateFieldGet(this, _Meld_tiles, "f").slice();
    }
    getMeldType() {
        return __classPrivateFieldGet(this, _Meld_meldType, "f");
    }
    getSuitType() {
        return __classPrivateFieldGet(this, _Meld_suitType, "f");
    }
    toString() {
        let result = '';
        for (const tile of __classPrivateFieldGet(this, _Meld_tiles, "f")) {
            result += tile.toString();
        }
        return result;
    }
    isIdentical(meldInput) {
        const isSameMeldType = __classPrivateFieldGet(this, _Meld_meldType, "f").valueOf() === meldInput.getMeldType().valueOf();
        if (isSameMeldType) {
            for (let i = 0; i < __classPrivateFieldGet(this, _Meld_tiles, "f").length; i++) {
                if (!__classPrivateFieldGet(this, _Meld_tiles, "f")[i].isIdentical(meldInput.getTiles()[i])) {
                    return false;
                }
            }
            return true;
        }
        else {
            return false;
        }
    }
    isValidEyes(inputTiles) {
        if (inputTiles.length !== Meld.NUMBER_OF_TILES_FOR_EYES) {
            return false;
        }
        return inputTiles[0].isIdentical(inputTiles[1]);
    }
    isValidKong(inputTiles) {
        const validTilesLength = inputTiles.length === Meld.NUMBER_OF_TILES_FOR_KONG;
        if (validTilesLength) {
            return this.allTilesAreSame(inputTiles);
        }
        else {
            return false;
        }
    }
    isValidPong(inputTiles) {
        const validTilesLength = inputTiles.length === Meld.NUMBER_OF_TILES_FOR_PONG;
        if (validTilesLength) {
            return this.allTilesAreSame(inputTiles);
        }
        else {
            return false;
        }
    }
    isValidChow(inputTiles) {
        const validTilesLength = inputTiles.length === Meld.NUMBER_OF_TILES_FOR_CHOW;
        const allTilesAreNotInHonorType = inputTiles.every((tile) => tile.getSuit() !== 'honor');
        if (validTilesLength && allTilesAreNotInHonorType) {
            const sortedTiles = inputTiles.sort((tile1, tile2) => tile1.getValue() - tile2.getValue());
            const firstAndSecondTilesAreConsecutive = sortedTiles[0].getValue() === sortedTiles[1].getValue() - 1;
            const secondAndThirdTilesAreConsecutive = sortedTiles[1].getValue() === sortedTiles[2].getValue() - 1;
            return firstAndSecondTilesAreConsecutive && secondAndThirdTilesAreConsecutive;
        }
        else {
            return false;
        }
    }
    allTilesAreSame(inputTiles) {
        for (let i = 0; i < inputTiles.length - 1; i++) {
            if (!inputTiles[i].isIdentical(inputTiles[i + 1])) {
                return false;
            }
        }
        return true;
    }
    allTilesAreInSameSuit(inputTiles) {
        for (let i = 0; i < inputTiles.length - 1; i++) {
            if (inputTiles[i].getSuit() !== inputTiles[i + 1].getSuit()) {
                return false;
            }
        }
        return true;
    }
}
exports.default = Meld;
_Meld_tiles = new WeakMap(), _Meld_suitType = new WeakMap(), _Meld_meldType = new WeakMap();
/**
 * The Eyes Meld should only consist of 2 Tiles.
 */
Meld.NUMBER_OF_TILES_FOR_EYES = 2;
/**
 * The Chow Meld should only consist of 3 Tiles.
 */
Meld.NUMBER_OF_TILES_FOR_CHOW = 3;
/**
 * The Pong Meld should only consist of 3 Tiles.
 */
Meld.NUMBER_OF_TILES_FOR_PONG = 3;
/**
 * The Kong Meld should only consist of 4 Tiles.
 */
Meld.NUMBER_OF_TILES_FOR_KONG = 4;
/**
 * The ThirteenOrphans Meld should only consist of 14 Tiles.
 */
Meld.NUMBER_OF_TILES_FOR_THIRTEEN_ORPHANS = 14;
